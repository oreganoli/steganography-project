using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Formats;
using SixLabors.ImageSharp.PixelFormats;
using System;
using System.IO;
namespace Oreganoli.SteganoToolkit;
/// <summary>
/// This class implements steganography for any lossless image format.
/// </summary>
public class LosslessStegano
{
    /// <summary>
    /// Writes a byte as a base-four representation to a 2x2 chunk in a pair of ImageSharp image rows.
    /// </summary>
    /// <param name="upper"></param>
    /// <param name="lower"></param>
    /// <param name="index"></param>
    /// <param name="value"></param>
    private static void WriteByteToChunk(Span<Rgba32> upper, Span<Rgba32> lower, int index, byte value)
    {
        if (upper.Length < 2 * (index + 1) || lower.Length < 2 * (index + 1))
        {
            throw new ArgumentException($"Provided an upper or lower row too short for an index of {index}");
        }
        var base4 = new BaseFour(value);
        var upperL = upper[index * 2];
        var upperR = upper[index * 2 + 1];

        #region Decrementation
        if (upperL.R - base4.SixtyFours < 0)
        {
            upperL.R += base4.SixtyFours;
        }
        else
        {
            upperL.R -= base4.SixtyFours;
        }
        if (upperL.G - base4.Sixteens < 0)
        {
            upperL.G += base4.Sixteens;
        }
        else
        {
            upperL.G -= base4.Sixteens;
        }
        if (upperL.B - base4.Fours < 0)
        {
            upperL.B += base4.Fours;
        }
        else
        {
            upperL.B -= base4.Fours;
        }
        if (upperR.R - base4.Ones < 0)
        {
            upperR.R += base4.Ones;
        }
        else
        {
            upperR.R -= base4.Ones;
        }
        #endregion
        ref Rgba32 lowerL = ref lower[index * 2];
        ref Rgba32 lowerR = ref lower[index * 2 + 1];
        lowerL = upperL;
        lowerR = upperR;
    }
    private static byte ReadByteFromChunk(Span<Rgba32> upper, Span<Rgba32> lower, int index)
    {
        var upperL = upper[index * 2];
        var upperR = upper[index * 2 + 1];
        var lowerL = lower[index * 2];
        var lowerR = lower[index * 2 + 1];
        var sixtyFours = (byte)Math.Abs(upperL.R - lowerL.R);
        var sixteens = (byte)Math.Abs(upperL.G - lowerL.G);
        var fours = (byte)Math.Abs(upperL.B - lowerL.B);
        var ones = (byte)Math.Abs(upperR.R - lowerR.R);
        #region obfuscation
        /* As cryptographers, we want our users to have plausible deniability.
        Therefore, attackers should not be able to easily find out
        which inputs are valid cryptograms generated by our tool and which are not.
        If we are fed values that are out of our ranges, we'll make some up. */
        if (sixtyFours > 3)
        {
            sixtyFours = (byte)(Random.Shared.Next() % 4);
        }
        if (sixteens > 3)
        {
            sixteens = (byte)(Random.Shared.Next() % 4);
        }
        if (fours > 3)
        {
            fours = (byte)(Random.Shared.Next() % 4);
        }
        if (ones > 3)
        {
            ones = (byte)(Random.Shared.Next() % 4);
        }
        #endregion
        return new BaseFour(sixtyFours, sixteens, fours, ones).AsByte();
    }
    public static void Encode(Stream input, Stream output, byte[] message, out IImageFormat format)
    {
        var img = Image.Load<Rgba32>(input, out format);
        if (format.Name == "JPEG" || format.Name == "GIF")
        {
            throw new UnsupportedImageFormatException(format.Name);
        }
        var columns = img.Width / 2;
        var rows = img.Height / 2;
        var msg = new byte[4 + message.Length];
        // Prepend the message's length to itself so we can know when to stop reading when decoding.
        Buffer.BlockCopy(BitConverter.GetBytes(message.Length), 0, msg, 0, 4);
        Buffer.BlockCopy(message, 0, msg, 4, message.Length);
        if (msg.Length > columns * rows)
        {
            throw new ImageTooSmallException(message.Length, img.Width);
        }
        columns = Math.Min(img.Width / 2, msg.Length);
        rows = (int)Math.Ceiling((float)msg.Length / (float)columns);
        img.ProcessPixelRows(accessor =>
        {
            var len = 0;
            for (var row = 0; row < rows; row++)
            {
                for (var col = 0; col < columns; col++)
                {
                    var upper = accessor.GetRowSpan(row * 2);
                    var lower = accessor.GetRowSpan(row * 2 + 1);
                    if (len < msg.Length)
                    {
                        //Console.WriteLine($"Writing byte {len + 1}/{msg.Length} to chunk {row},{col}");
                        WriteByteToChunk(upper, lower, col, msg[len]);
                        len++;
                    }
                }
            }
        });
        img.Save(output, format);
    }
    public static void Decode(Stream input, Stream output)
    {
        var img = Image.Load<Rgba32>(input, out var format);
        if (format.Name == "JPEG" || format.Name == "GIF")
        {
            throw new UnsupportedImageFormatException(format.Name);
        }
        var columns = img.Width / 2;
        var rows = img.Height / 2;
        var expectedLength = 4;
        var lengthBuffer = new byte[4];
        img.ProcessPixelRows(accessor =>
        {
            var len = 0;
            for (var row = 0; row < rows; row++)
            {
                for (var col = 0; col < columns && len < expectedLength; col++)
                {
                    var upper = accessor.GetRowSpan(row * 2);
                    var lower = accessor.GetRowSpan(row * 2 + 1);
                    //Console.WriteLine($"Reading byte from chunk {row},{col}");
                    var val = ReadByteFromChunk(upper, lower, col);
                    if (len < 4)
                    {
                        lengthBuffer[len] = val;
                        if (len == 3)
                        {
                            expectedLength = BitConverter.ToInt32(lengthBuffer, 0) + 4;
                            Console.WriteLine($"Expected length: {expectedLength}");
                        }
                        len++;
                    }
                    else
                    {
                        output.WriteByte(val);
                        len++;
                    }
                }
            }
            output.Flush();
        });
    }
}